// wwwroot/js/vulnerability-common.js

window.VulnerabilityTester = (function () {
    'use strict';

    // Configuration par défaut
    const defaultConfig = {
        attackTypeSelectId: 'attackType',
        exampleDivId: 'payloadExample',
        exampleContentId: 'payloadExampleContent',
        useExampleBtnId: 'useExampleBtn',
        payloadInputId: 'payload',
        testHistoryId: 'testHistory',
        attackInfosDataId: 'attackInfosData',
        maxHistoryItems: 10,
        debug: true
    };

    // Classe principale
    class VulnerabilityTester {
        constructor(config = {}) {
            this.config = { ...defaultConfig, ...config };
            this.attackInfos = {};
            this.isInitialized = false;
            this.testHistory = [];
            this.elements = {};

            if (this.config.debug) {
                console.log(`=== INITIALISATION ${this.config.vulnerabilityType || 'VULNERABILITY'} ===`);
            }
        }

        // Initialisation
        initialize() {
            if (this.isInitialized) {
                this.log('Déjà initialisé');
                return;
            }

            // Étapes d'initialisation
            if (!this.initializeElements()) {
                this.error('Échec de l\'initialisation des éléments DOM');
                return;
            }

            if (!this.loadAttackInfos()) {
                this.error('Échec du chargement des données');
                return;
            }

            if (!this.attachEventListeners()) {
                this.error('Échec de l\'attachement des events');
                return;
            }

            // Initialiser avec la valeur actuelle si nécessaire
            const currentAttackType = this.elements.attackTypeSelect.value;
            if (currentAttackType && !this.elements.payloadInput.value) {
                this.updatePayload();
            }

            // Callback personnalisé après initialisation
            if (this.config.onInitialized) {
                this.config.onInitialized.call(this);
            }

            this.isInitialized = true;
            this.log('=== INITIALISATION RÉUSSIE ===');
        }

        // Initialisation des éléments DOM
        initializeElements() {
            this.elements = {
                attackTypeSelect: document.getElementById(this.config.attackTypeSelectId),
                exampleDiv: document.getElementById(this.config.exampleDivId),
                exampleContent: document.getElementById(this.config.exampleContentId),
                useExampleBtn: document.getElementById(this.config.useExampleBtnId),
                payloadInput: document.getElementById(this.config.payloadInputId),
                form: document.querySelector('form'),
                testHistory: document.getElementById(this.config.testHistoryId)
            };

            this.log('Éléments initialisés:', {
                select: !!this.elements.attackTypeSelect,
                input: !!this.elements.payloadInput,
                example: !!this.elements.exampleDiv
            });

            return this.elements.attackTypeSelect && this.elements.payloadInput;
        }

        // Chargement des données JSON
        loadAttackInfos() {
            try {
                const dataScript = document.getElementById(this.config.attackInfosDataId);
                if (!dataScript || !dataScript.textContent) {
                    this.error('Script de données non trouvé');
                    return false;
                }

                this.log('Données JSON trouvées, parsing...');
                this.attackInfos = JSON.parse(dataScript.textContent);
                this.log('AttackInfos chargées:', Object.keys(this.attackInfos));

                // Vérification des payloadExample
                Object.keys(this.attackInfos).forEach(key => {
                    const payload = this.getPayloadExample(this.attackInfos[key]);
                    this.log(`${key}: ${payload}`);
                });

                return true;
            } catch (e) {
                this.error('Erreur de parsing JSON:', e);
                return false;
            }
        }

        // Obtenir le payload (gestion camelCase/PascalCase)
        getPayloadExample(attackInfo) {
            return attackInfo.payloadExample || attackInfo.PayloadExample || '';
        }

        // Mise à jour du payload
        updatePayload() {
            if (!this.elements.attackTypeSelect || !this.elements.payloadInput) {
                this.error('Éléments requis non trouvés');
                return;
            }

            const selectedType = this.elements.attackTypeSelect.value;
            this.log('Type sélectionné:', selectedType);

            if (!selectedType) {
                this.clearSelection();
                return;
            }

            if (this.attackInfos[selectedType]) {
                const attackInfo = this.attackInfos[selectedType];
                const payload = this.getPayloadExample(attackInfo);

                if (payload) {
                    this.log('Payload trouvé:', payload);
                    this.setPayload(payload);
                    this.showExample(payload);
                } else {
                    this.error('Pas de payload pour:', selectedType);
                }
            } else {
                this.error('Type d\'attaque non trouvé:', selectedType);
            }

            // Nettoyer les résultats si configuré
            if (this.isInitialized && this.config.clearResultsOnChange) {
                this.clearPreviousResults();
            }
        }

        // Définir le payload
        setPayload(payload) {
            this.elements.payloadInput.value = payload;
            setTimeout(() => {
                this.elements.payloadInput.focus();
                this.elements.payloadInput.select();
            }, 50);
        }

        // Afficher l'exemple
        showExample(payload) {
            if (this.elements.exampleContent) {
                this.elements.exampleContent.textContent = payload;
            }
            if (this.elements.exampleDiv) {
                this.elements.exampleDiv.style.display = 'block';
            }
            if (this.elements.useExampleBtn) {
                this.elements.useExampleBtn.style.display = 'block';
            }
        }

        // Vider la sélection
        clearSelection() {
            this.elements.payloadInput.value = '';
            if (this.elements.exampleDiv) this.elements.exampleDiv.style.display = 'none';
            if (this.elements.useExampleBtn) this.elements.useExampleBtn.style.display = 'none';
        }

        // Nettoyer les résultats précédents
        clearPreviousResults() {
            if (!this.isInitialized) {
                this.log('Initialisation en cours - pas de nettoyage');
                return;
            }

            this.log('Nettoyage des résultats précédents');

            // Appel du callback personnalisé si fourni
            if (this.config.onClearResults) {
                this.config.onClearResults.call(this);
            }
        }

        // Attacher les event listeners
        attachEventListeners() {
            if (!this.elements.attackTypeSelect) {
                this.error('Select element non trouvé');
                return false;
            }

            // Changement de type d'attaque
            this.elements.attackTypeSelect.addEventListener('change', (event) => {
                this.log('=== CHANGEMENT DÉTECTÉ ===');
                this.log('Nouvelle valeur:', event.target.value);
                this.updatePayload();
            });

            // Bouton "Utiliser"
            if (this.elements.useExampleBtn) {
                this.elements.useExampleBtn.addEventListener('click', () => {
                    this.log('Bouton Utiliser cliqué');
                    this.useExample();
                });
            }

            // Soumission du formulaire
            if (this.elements.form) {
                this.elements.form.addEventListener('submit', () => {
                    const attackType = this.elements.attackTypeSelect.value;
                    const payload = this.elements.payloadInput.value;

                    if (attackType && payload) {
                        this.addToHistory(attackType, payload, true);
                    }
                });
            }

            this.log('Event listeners attachés');
            return true;
        }

        // Utiliser l'exemple
        useExample() {
            const selectedType = this.elements.attackTypeSelect.value;
            if (selectedType && this.attackInfos[selectedType]) {
                const payload = this.getPayloadExample(this.attackInfos[selectedType]);
                if (payload) {
                    this.setPayload(payload);
                }
            }
        }

        // Gestion de l'historique
        addToHistory(attackType, payload, success) {
            const entry = {
                timestamp: new Date().toLocaleString(),
                attackType: attackType,
                payload: payload,
                success: success
            };

            this.testHistory.unshift(entry);

            if (this.testHistory.length > this.config.maxHistoryItems) {
                this.testHistory = this.testHistory.slice(0, this.config.maxHistoryItems);
            }

            this.updateHistoryDisplay();
        }

        // Mettre à jour l'affichage de l'historique
        updateHistoryDisplay() {
            if (!this.elements.testHistory) return;

            if (this.testHistory.length === 0) {
                this.elements.testHistory.innerHTML = '<p class="text-muted">Aucun test effectué dans cette session.</p>';
                return;
            }

            const historyHtml = this.testHistory.map(entry => `
                <div class="border-bottom pb-2 mb-2 ${entry.success ? 'text-success' : 'text-danger'}">
                    <small class="text-muted">${entry.timestamp}</small><br>
                    <strong>${entry.attackType.toUpperCase()}</strong>: <code>${VulnerabilityTester.escapeHtml(entry.payload)}</code>
                    <span class="badge ${entry.success ? 'bg-success' : 'bg-danger'} ms-2">
                        ${entry.success ? 'Succès' : 'Erreur'}
                    </span>
                </div>
            `).join('');

            this.elements.testHistory.innerHTML = historyHtml;
        }

        // Logging
        log(...args) {
            if (this.config.debug) {
                console.log(...args);
            }
        }

        error(...args) {
            console.error(...args);
        }

        // Méthodes statiques utilitaires
        static escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        static async copyToClipboard(text, buttonElement) {
            try {
                await navigator.clipboard.writeText(text);

                if (buttonElement) {
                    const originalHtml = buttonElement.innerHTML;
                    buttonElement.innerHTML = '<i class="fas fa-check"></i> Copié!';
                    setTimeout(() => {
                        buttonElement.innerHTML = originalHtml;
                    }, 2000);
                }

                return true;
            } catch (err) {
                console.error('Erreur copie:', err);

                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();

                try {
                    document.execCommand('copy');
                    return true;
                } catch (execErr) {
                    console.error('Échec de la copie:', execErr);
                    return false;
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        }

        static convertToCSV(data, headers) {
            if (!Array.isArray(data) || !data.length) return '';

            const escapeField = field => `"${String(field || '').replace(/"/g, '""')}"`;

            // Si les headers ne sont pas fournis, les extraire des données
            if (!headers) {
                headers = Object.keys(data[0]);
            }

            return [
                headers.join(','),
                ...data.map(row => headers.map(header => escapeField(row[header])).join(','))
            ].join('\n');
        }

        static downloadCSV(csv, filename) {
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    }

    // Retourner la classe pour utilisation
    return VulnerabilityTester;
})();